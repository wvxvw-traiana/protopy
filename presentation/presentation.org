#+TITLE:     Comparing Protobuf to AMF
#+AUTHOR:    Oleg Sivokon
#+EMAIL:     olegsivokon@gmail.com
#+DATE:      <2018-06-27 Wed>
#+DESCRIPTION: Comparing Protobuf to AMF
#+KEYWORDS: Protobuf Protocol Buffers ActionScript Message Format
#+LANGUAGE:  en
#+OPTIONS:   H:2 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:nil toc:nil ltoc:t mouse:underline buttons:0 path:http://orgmode.org/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME:
#+startup: beamer
#+LaTeX_CLASS: beamer
#+LaTeX_CLASS_OPTIONS: [presentation]
#+BEAMER_THEME: metropolis
#+COLUMNS: %40ITEM %10BEAMER_env(Env) %9BEAMER_envargs(Env Args) %4BEAMER_col(Col) %10BEAMER_extra(Extra)

* Some historical context

** Battle for web dominance
  + HTML rules the web.  XSL and then SOAP are poorly accepted.
  + PHP, unlike ASP or JSP streams page content.
  + Macromedia, then Adobe Flash needs streaming for interactivity.
  + AMF gives Flash a competitive edge over SOAP.
  + AMFPHP first, then others implement AMF.
  + Adobe and Mozilla lose standards battle to Google, MS and Apple.
  + Protobuf is positioned to replace AMF.

* Metadata vs no metadata

** AMF: yes to metadata
   + Easy debugging.
   + No need for codegeneration.
   + Some overhead in short messages.
   + Potential for references, richer vocabulary.

** Protobuf: no to metadata
   + Invention of Descriptor (fixed point description of description).
   + Extensive infrastrucutre.  Pros: more tools.  Cons: more work.
     - Special RPC description language.
     - Special language-independent language for binary data
       description.
   + Multiple encoding layers: wire-type, value-type,
     application-type.

* Technical details of Protobuf
  
** Message description
   + Formal grammar attempted, but not verified.
   + Proliferation of special cases.
   + Confusion about semicolons.
   + Implementing parser is not enough.

** Illustration I
   #+BEGIN_SRC protobuf
     syntax = "protobuf3";

     import "another.proto";

     enum Enum {
         MEMBER_1 = 1;  // Enumerations must not be zero
         MEMBER_2 = 3;
     }
   #+END_SRC

** Illustration II
   #+BEGIN_SRC protobuf
     syntax = "protobuf3";
     package some.package;

     message Message {
         message NestedMessage {
             repeated int32 repeated_field = 1;
         }
         NestedMessage nested = 1;
         oneof unnecessary_name {
             int32 either = 2;  // Must be distinct
             string or = 3;
         }
         map<int32, NestedMessage> a_map = 4;
     }
   #+END_SRC

** Binary protocol
   + Wire-types: very limited.
   + Value-types: no pointers.
   + Application types: open to interpretation.

** Illustration
   Wire-level deals with key-value pairs
   #+BEGIN_SRC ditaa :file ./images/wire-types.eps :eps t
     +-------------+-------------+
     | varint(key) | field value |
     +-------------+-------------+

     +-------------+---------------+ 
     | varint(key) | varint(value) |
     +-------------+---------------+

     +-------------+----------------+ 
     | varint(key) | fixed64(value) |
     +-------------+----------------+

     +-------------+----------------+ 
     | varint(key) | fixed32(value) |
     +-------------+----------------+

     +-------------+----------------+-------+
     | varint(key) | varint(length) | value |
     +-------------+----------------+-------+
   #+END_SRC

   #+attr_LaTeX: :height 7cm
   #+RESULTS:
   [[file:./images/wire-types.eps]]

** Value types
   + =int= and =uint= types behave exactly the same way
   + =repeated= types are, in fact, encoded differently, depending
     on the type being a =scalar= or not.
   + $sintXX(V)$ are encoded as
     $intXX(|V| \times 2 - (\frac{V}{|V|} - 1) \times \frac{1}{2})$.

   | varint           | int32   | int64    | sint32  | sint64   |
   |------------------+---------+----------+---------+----------|
   | fixed64          | fixed64 | sfixed64 | double  |          |
   |------------------+---------+----------+---------+----------|
   | fixed32          | fixed32 | sfixed32 |         |          |
   |------------------+---------+----------+---------+----------|
   | lenght-delimited | bytes   | string   | message | repeated |

** Application types
   + Must be messages or enumerators.
   + May contain extra fields, or may lack fields.
   + Contain no identifying information.
   + Repeated fields (and map fields) cannot be nested.

* Reference

** Links
  + [[http://ncannasse.fr/blog/ecmascript_4_and_the_web?lang=en][Cannasse: Ecmascript 4 and the web]]
  + [[http://ncannasse.fr/blog/ecmascript_disharmony?lang=en][Cannasse: Ecmascript discharmony]]
  + [[https://www.silexlabs.org/amfphp/][AMFPHP]]
  + [[https://en.wikipedia.org/wiki/Action_Message_Format][Wikipedia: AMF]]
  + [[https://developers.google.com/protocol-buffers/docs/reference/proto3-spec][Protobuf language specification]]
